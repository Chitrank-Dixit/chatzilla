{"name":"Chatzilla","tagline":"","body":"# Realtime chat with Flask and Heroku \r\n\r\n\r\nThis is a step by step tutorial on building a basic real time chat application using [Flask](http://flask.pocoo.org/), [socket.io](http://socket.io/) and [gevent-socketio](https://github.com/abourget/gevent-socketio). All the code is available [here](https://github.com/callmephilip/chatzilla). You can find live version of the app [here](chatzilla.herokuapp.com).   \r\n\r\n\r\n\r\n> As of Oct 8 2013, Heroku rolled out Public Beta of Websockets. The official announcement can be found [here](https://blog.heroku.com/archives/2013/10/8/websockets-public-beta). \r\n\r\nIf you don't enable Websocket functionality on Heroku, Socket.io will fallback to XHR polling.\r\n\r\nTo enable websockets on your Heroku app, use the following command\r\n\r\n```\r\nheroku labs:enable websockets -a YOUR-APP-NAME\r\n``` \r\n   \r\n## Chapter 1: Getting started \r\n\r\nI assume you know what Heroku is and you've seen Python before. Prior knowledge of Flask is a plus but given how minimalistic it is, you can just tag along.  \r\n\r\n\r\n### Heroku up\r\n\r\nFirst things first, let's create a shiny new appication on Heroku\r\n\r\n```\r\nheroku apps:create YOUR_APPLICATION_NAME\r\n```\r\n\r\nI called my app 'chatzilla' and got the following output\r\n\r\n```\r\nCreating chatzilla... done, stack is cedar\r\nhttp://chatzilla.herokuapp.com/ | git@heroku.com:chatzilla.git\r\n``` \r\n\r\nThe git part is important, let's put it to good use. Let's setup a git repository and point it towards heroku \r\n\r\n```\r\ngit init\r\ngit remote add heroku git@heroku.com:<YOUR_APP_NAME>.git\r\n```\r\n\r\nWe now have an empty git repository with a remote aliased 'heroku' pointing to the Heroku git for the project. The game is afoot. \r\n\r\n### Setup basic Flask app\r\n\r\n#### Virtual environment\r\n\r\nAs every responsible Python developer, you use some kind of virtual environment manager (I personally use [virtual env wrapper](http://virtualenvwrapper.readthedocs.org/en/latest/index.html)). Create a virtual environment named 'chatzilla' (or something else) and automatically activate it:\r\n\r\n```\r\nmkvirtualenv chatzilla\r\n``` \r\n\r\nVirtual envs save your mental health and remaining hair, so use them. \r\n\r\n#### Get all the goods using Pip\r\n\r\nPip is great for getting all your jazz organized. We'll be using it to install all the modules we need to make Chatzilla happen.\r\n\r\n```\r\npip install Flask gevent gevent-websocket gevent-socketio gunicorn==0.16.1 \r\n```\r\n\r\nPlease note we are using a particular version of the gunicor since later versions seem to have certain [issues](stackoverflow.com/questions/14656841/geventsocketioworker-has-no-attribute-socket). \r\n\r\n#### Freeze\r\n\r\nOnce Pip has installed all the modules to our previously pristine virtual environment, it's time to get a snapshot of what's installed so that when you move your app elsewhere, you can easily restore the environment\r\n\r\n```\r\npip freeze > requirements.txt\r\n```\r\n\r\nYour requirements.txt should look something like this\r\n\r\n```\r\nFlask==0.10.1\r\nJinja2==2.7.1\r\nMarkupSafe==0.18\r\nWerkzeug==0.9.4\r\ngevent==0.13.8\r\ngevent-socketio==0.3.5-rc2\r\ngevent-websocket==0.3.6\r\ngreenlet==0.4.1\r\ngunicorn==0.16.1\r\nitsdangerous==0.23\r\nwsgiref==0.1.2\r\n``` \r\n\r\n#### chatzilla.py\r\n\r\nLet's create an entry point for the application now\r\n\r\n```\r\ntouch chatzilla.py\r\n``` \r\n\r\nLet's fill it with some Python\r\n\r\n```python\r\nfrom gevent import monkey\r\nfrom flask import Flask\r\n\r\nmonkey.patch_all()\r\n\r\napplication = Flask(__name__)\r\napplication.debug = True\r\napplication.config['PORT'] = 5000\r\n\r\n\r\n@application.route('/', methods=['GET'])\r\ndef landing():\r\n    return \"Welcome to Chatzilla\"\r\n``` \r\n\r\nIn it's current state, our app has none of the promised realtime awesomeness but we'll get there - one step at a time. \r\n\r\n#### run_server.py\r\n\r\nIn order to run chatzilla, we'll add another python module\r\n\r\n```\r\ntouch run_server.py\r\n``` \r\n\r\nIt looks like this:\r\n\r\n```python\r\nfrom chatzilla import application\r\nfrom gevent import monkey\r\nfrom socketio.server import SocketIOServer\r\n\r\n\r\nmonkey.patch_all()\r\n\r\nif __name__ == '__main__':\r\n    SocketIOServer(\r\n    \t('', application.config['PORT']), \r\n    \tapplication,\r\n    \tresource=\"socket.io\").serve_forever()\r\n```\r\n\r\n### Procfile : Flask meets Heroku \r\n\r\nBefore a much deserved refreshing beverage, let's tell Heroku how to run our application using Procfile\r\n\r\n```\r\ntouch Procfile\r\n```\r\n\r\nInside:\r\n\r\n```\r\nweb: gunicorn --worker-class socketio.sgunicorn.GeventSocketIOWorker run_server\r\n```\r\n\r\nThis is basically us saying: could we have a web instance running gunicorn with a worker that can speak socket.io and yeah, check run_server.py for more instructions, por favor.\r\n\r\n### But will it blend?\r\n\r\nLet's see if this works\r\n\r\n```\r\nforeman start\r\n```\r\n\r\nThis should launch a local dev server on your machine. If you head to http://localhost:5000/, you should be able to witness Chatzilla in all its glory.\r\n\r\nLet's go global now \r\n\r\n```\r\ngit add .\r\ngit commit -a -m \"setup basic Flask app\"\r\ngit push heroku master\r\n``` \r\n\r\nThis should keep Heroku busy for a few moments. Once it's done processing the push, we can take a look at Chatzilla in the wild\r\n\r\n```\r\nheroku open\r\n```\r\n\r\n### Before you panic\r\n\r\nJust in case you are stuck/confused/lazy, you can grab all the code we've produced so far [here](https://github.com/callmephilip/chatzilla/releases/tag/v0.1) and keep following along.  \r\n\r\n\r\n## Chapter 2: Sockets, por favor\r\n\r\n### Wire a namespace\r\n\r\nWe currently have a socket.io endpoint exposed to the world and we should start handling various events that will get triggered once people start using it. Head to chatzilla.py and add the following:\r\n\r\n```python\r\n@application.route('/socket.io/<path:remaining>')\r\ndef socketio(remaining):\r\n    try:\r\n        socketio_manage(request.environ, {'/chat': ChatNamespace}, request)\r\n    except:\r\n        application.logger.error(\"Exception while handling socketio connection\",\r\n                         exc_info=True)\r\n    return Response()\r\n\r\n```  \r\n\r\nAlso update import statements on the top of the module: \r\n\r\n```python\r\nfrom flask import Flask, Response, render_template, request\r\nfrom socketio import socketio_manage\r\n```\r\n\r\nsocketio function maps to the /socket.io/someotherstuff url and this is how the client side of the Chatzilla will try to reach out to the server with some urgent real time goodness. We obviously need to handle that, and we are doing it by proxying the request to ChatNamespace (which we'll create in a second). \r\n\r\nNamespaces give us a way to manage various sub categories within a socket.io endpoint. For Chatzilla we will only be using a single such category called 'chat'. Let's look what a namespace definition might look like in our case:\r\n\r\n```python\r\nclass ChatNamespace(BaseNamespace):\r\n    def initialize(self):\r\n        self.logger = application.logger\r\n        self.log(\"Socketio session started\")\r\n\r\n    def log(self, message):\r\n        self.logger.info(\"[{0}] {1}\".format(self.socket.sessid, message))\r\n\r\n    def recv_connect(self):\r\n        self.log(\"New connection\")\r\n\r\n    def recv_disconnect(self):\r\n        self.log(\"Client disconnected\")\r\n```  \r\n\r\nChatNamespace does not do a lot at this point - it logs connects and disconnects and that's it. Make sure you add the missing import to the chatzilla.py \r\n\r\n```python\r\nfrom socketio.namespace import BaseNamespace\r\n``` \r\n\r\n### Client is always right\r\n\r\nLet's try to figure out if we can actually connect to the chat server from the client. One step at a time.\r\n\r\n#### Massive redesign\r\n\r\nLet's fix our landing page a bit. Start by bringing in templates\r\n\r\n```\r\nmkdir templates\r\ncd templates\r\ntouch landing.html\r\n``` \r\n\r\nPopulate landing.html with the following html\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<!--[if lt IE 7]> <html class=\"no-js lt-ie9 lt-ie8 lt-ie7\"> <![endif]-->\r\n<!--[if IE 7]> <html class=\"no-js lt-ie9 lt-ie8\"> <![endif]-->\r\n<!--[if IE 8]> <html class=\"no-js lt-ie9\"> <![endif]-->\r\n<!--[if gt IE 8]><!--> <html class=\"no-js\"> <!--<![endif]-->\r\n<head>\r\n\t<meta charset=\"utf-8\">\r\n\t<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\r\n\t<meta http-equiv=\"cache-control\" content=\"no-cache\" />\r\n\t<title>Chatzilla</title>\r\n</head>\r\n<body>\r\n\t<header>\r\n\t\t<h1>Welcome to Chatzilla</h1>\r\n\t</header>\r\n\t<footer></footer>\r\n\r\n\t<script src=\"http://code.jquery.com/jquery-1.10.1.min.js\"></script>\r\n\t<script>\r\n\t\t$(function(){\r\n\t\t\tconsole.log(\"Welcome to Chatzilla\");\r\n\t\t});\r\n\t</script>\r\n</body>\r\n</html>\r\n```\r\n\r\n\r\nNow let's render the template using Flask:\r\n\r\n```python\r\n@application.route('/', methods=['GET'])\r\ndef landing():\r\n    return render_template('landing.html')\r\n```\r\n\r\nDon't forget imports\r\n\r\n```python\r\nfrom flask import Flask, Response, render_template\r\n```\r\n\r\nOnce you run ```foreman start``` you should see a shiny new Chatzilla interface. Epic.\r\n\r\n#### Wire the socket\r\n\r\nLet's bring socket.io javascript goodness in the mix. \r\n\r\n```\r\nmkdir static\r\ncd static\r\nmkdir scripts\r\ncd scripts\r\ncurl -O https://dl.dropboxusercontent.com/u/9224326/www/chatzilla/scripts/socket.io.min.js \r\n-O https://dl.dropboxusercontent.com/u/9224326/www/chatzilla/scripts/WebSocketMain.swf \r\n-O https://dl.dropboxusercontent.com/u/9224326/www/chatzilla/scripts/WebSocketMainInsecure.swf\r\n``` \r\n\r\nLet's update templates/landing.html to include socket.io\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<!--[if lt IE 7]> <html class=\"no-js lt-ie9 lt-ie8 lt-ie7\"> <![endif]-->\r\n<!--[if IE 7]> <html class=\"no-js lt-ie9 lt-ie8\"> <![endif]-->\r\n<!--[if IE 8]> <html class=\"no-js lt-ie9\"> <![endif]-->\r\n<!--[if gt IE 8]><!--> <html class=\"no-js\"> <!--<![endif]-->\r\n<head>\r\n\t<meta charset=\"utf-8\">\r\n\t<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\r\n\t<meta http-equiv=\"cache-control\" content=\"no-cache\" />\r\n\t<title>Chatzilla</title>\r\n</head>\r\n<body>\r\n\t<header>\r\n\t\t<h1>Welcome to Chatzilla</h1>\r\n\t</header>\r\n\t<footer></footer>\r\n\r\n\t<script src=\"http://code.jquery.com/jquery-1.10.1.min.js\"></script>\r\n\t<script src=\"{{ url_for('static', filename='scripts/socket.io.min.js') }}\"></script>\r\n\t<script>\r\n\t\t$(function(){\r\n\t\t\tconsole.log(\"Welcome to Chatzilla\");\r\n\t\t});\r\n\t</script>\r\n</body>\r\n</html>\r\n```\r\n\r\n### Connect to the server\r\n\r\nWith socket.io javascript in place, we can now connect to our chat instance. Update landing.html template with the following code\r\n\r\n```javascript\r\n$(function(){\r\n\tconsole.log(\"Welcome to Chatzilla\");\r\n\tvar socket = io.connect('/chat');\r\n\tsocket.on('connect', function () {\r\n\t\talert(\"You are connected to the chat server\");\r\n\t});\r\n});\r\n```\r\nRefresh the page to see the popup. Hooray!\r\n\r\n### Join the chat\r\n\r\nOnce connected to the chat server, we should be able to join chat. Let's implement that. Jump back to chatzilla.py and add the following block to the ChatNamespace:\r\n\r\n```python\r\ndef on_join(self, name):\r\n\tself.log(\"%s joined chat\" % name)\r\n\treturn True, name\r\n```   \r\n\r\nBack to the client, let's update the 'connect' event handler \r\n\r\n```javascript\r\nsocket.on('connect', function () {\r\n\tsocket.emit('join', 'Bob', function(joined, name){\r\n\t\tconsole.log(joined,name);\r\n\t});\r\n});\r\n```\r\n\r\nNotice how return values from the on_join in the ChatNamespace are automatically propagate to the client and we can recover them in the event handler for the emit method.\r\n\r\n### Send a message\r\n\r\nLet's add message sending functionality to the chat service. Start with the backend again\r\n\r\n```python\r\ndef on_message(self, message):\r\n\tself.log('got a message: %s' % message)\r\n\treturn True, message\r\n``` \r\n\r\nAnd now the client, let's automatically send a message once someone joins the chat\r\n\r\n```javascript\r\nsocket.emit('join', 'Bob', function(joined, name){\r\n\tsocket.emit('message', 'hello this is ' + name, function(sent){\r\n\t\tconsole.log(\"message sent: \", sent);\r\n\t});\r\n});\r\n```\r\n\r\n### Broadcast\r\n\r\nWhen a new message arrives to the server, we will want to send it to other people in the system. Let's get back to the ChatNamespace in chatzilla.py and add a BroadcastMixin which will help us do just that\r\n\r\n```python\r\nclass ChatNamespace(BaseNamespace, BroadcastMixin):\r\n```\r\n\r\nKeeping imports happy\r\n\r\n```python\r\nfrom socketio.mixins import BroadcastMixin\r\n```\r\n\r\nWith BroadcastMixin attached to the ChatNamespace, we can update the on_message handler to look like this\r\n\r\n```python\r\ndef on_message(self, message):\r\n\tself.log('got a message: %s' % message)\r\n\tself.broadcast_event_not_me(\"message\", message)\r\n\treturn True, message\r\n```\r\n\r\nWe can now update the client to look something like this\r\n\r\n```javascript\r\n$(function(){\r\n\tconsole.log(\"Welcome to Chatzilla\");\r\n\tvar socket = io.connect('/chat');\r\n\tsocket.on('connect', function () {\r\n\t\tsocket.emit('join', 'Bob', function(joined, name){\r\n\t\t\tsocket.emit('message', 'hello this is ' + name, function(sent){\r\n\t\t\t\tconsole.log(\"message sent: \", sent);\r\n\t\t\t});\r\n\t\t});\r\n\t});\r\n\r\n\tsocket.on('message', function(message){\r\n\t\talert(\"got a message: \" + message);\r\n\t});\r\n});\r\n```  \r\n\r\nIf you now have a couple of tabs open in your browser you'll see an alert box with a greeting from Bob.\r\n\r\n### Let's deploy\r\n\r\nTons of users out there are looking forward to experiencing the new version of Chatzilla. Commit your changes, and push. \r\n\r\n### Before you panic\r\n\r\nAs before, you can grab the code for this chapter [here](https://github.com/callmephilip/chatzilla/releases/tag/v0.2)   \r\n \r\n\r\n## Chapter 3 : UI\r\n\r\nNow that we have a functioning client-server communication model, let's add some UI on top of that so that people can control what data gets sent to the server + get rid of alert popups and display data more gracefully.\r\n\r\n### Move some stuff around\r\n\r\nLet's isolate client side code in a separate module so we can stop poluting the landing page template\r\n\r\n```\r\ntouch static/scripts/chatzilla.js\r\n```    \r\n\r\nLet's move all the inline js from the landing template to chatzilla.js so it looks like this\r\n\r\n```javascript\r\n(function($,window){\r\n\t$(function(){\r\n\t\tconsole.log(\"Welcome to Chatzilla\");\r\n\t\tvar socket = io.connect('/chat');\r\n\t\tsocket.on('connect', function () {\r\n\t\t\tsocket.emit('join', 'Bob', function(joined, name){\r\n\t\t\t\tsocket.emit('message', 'hello this is ' + name, function(sent){\r\n\t\t\t\t\tconsole.log(\"message sent: \", sent);\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\tsocket.on('message', function(message){\r\n\t\t\talert(\"got a message: \" + message);\r\n\t\t});\r\n\t});\r\n}($,window));\r\n```\r\n\r\nThe landing template should now look something like this\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<!--[if lt IE 7]> <html class=\"no-js lt-ie9 lt-ie8 lt-ie7\"> <![endif]-->\r\n<!--[if IE 7]> <html class=\"no-js lt-ie9 lt-ie8\"> <![endif]-->\r\n<!--[if IE 8]> <html class=\"no-js lt-ie9\"> <![endif]-->\r\n<!--[if gt IE 8]><!--> <html class=\"no-js\"> <!--<![endif]-->\r\n<head>\r\n\t<meta charset=\"utf-8\">\r\n\t<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\r\n\t<meta http-equiv=\"cache-control\" content=\"no-cache\" />\r\n\t<title>Chatzilla</title>\r\n</head>\r\n<body>\r\n\t<header>\r\n\t\t<h1>Welcome to Chatzilla</h1>\r\n\t</header>\r\n\t<footer>\r\n\t</footer>\r\n\r\n\t<script src=\"http://code.jquery.com/jquery-1.10.1.min.js\"></script>\r\n\t<script src=\"{{ url_for('static', filename='scripts/socket.io.min.js') }}\"></script>\r\n\t<script src=\"{{ url_for('static', filename='scripts/chatzilla.js') }}\"></script>\r\n</body>\r\n</html>\r\n```\r\n  \r\n### Add join chat UI\r\n\r\nLet's add a little join chat form in a section between the header and the footer of the landing page\r\n\r\n```html\r\n<section>\r\n\t<form class=\"join-chat\">\r\n\t\t<label>Type your email to join the chat</label>\r\n\t\t<input name=\"email\" type=\"email\">\r\n\t\t<input type=\"submit\" value=\"Join\">\r\n\t</form>\r\n</section>\r\n```\r\n\r\nBefore we wire the handlers for the form, let's grab [jquery validation plugin])(http://jqueryvalidation.org/) we can put ot good use here. Place this right after the jquery script tag.\r\n\r\n```html\r\n<script src=\"http://ajax.aspnetcdn.com/ajax/jquery.validate/1.11.1/jquery.validate.min.js\"></script>\r\n```\r\n\r\nLet's update chatzilla.js to handle form submission + validation\r\n\r\n```javascript\r\n(function($,window){\r\n\t\r\n\r\n\tvar bindUI = function(){\r\n\t\t\r\n\t\t$(\".join-chat\").validate({\r\n\t\t\tsubmitHandler: function(form) {\r\n\t\t\t\tconsole.log($(form).find(\"[name='email']\").val() + \r\n\t\t\t\t\t\" wants to join the chat\");\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\r\n\tvar ready = function(){\r\n\r\n\t\tbindUI();\r\n\r\n\t\tconsole.log(\"Welcome to Chatzilla\");\r\n\t\tvar socket = io.connect('/chat');\r\n\t\tsocket.on('connect', function () {\r\n\t\t\tsocket.emit('join', 'Bob', function(joined, name){\r\n\t\t\t\tsocket.emit('message', 'hello this is ' + name, function(sent){\r\n\t\t\t\t\tconsole.log(\"message sent: \", sent);\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\tsocket.on('message', function(message){\r\n\t\t\talert(\"got a message: \" + message);\r\n\t\t});\r\n\t};\r\n\r\n\r\n\r\n\t$(function(){ ready(); });\r\n\r\n}($,window));\r\n```\r\n\r\nLet's also start organizing our socket interactions so we can easily call our chat server from various UI event handlers. Here's how this little submodule could look like (with 2 methods for now):\r\n\r\n```javascript\r\nvar chatAPI = {\r\n\tconnect : function(done) {\r\n\t\tthis.socket = io.connect('/chat');\r\n\t\tthis.socket.on('connect', done);\r\n\t},\r\n\r\n\tjoin : function(email, onJoin){\r\n\t\tthis.socket.emit('join', email, onJoin);\r\n\t}\r\n\r\n};\t\r\n```\r\n\r\nAnd as we update the rest of chatzilla.js: \r\n\r\n```javascript\r\n(function($,window){\r\n\t\r\n\tvar chatAPI = {\r\n\r\n\t\tconnect : function(done) {\r\n\t\t\tthis.socket = io.connect('/chat');\r\n\t\t\tthis.socket.on('connect', done);\r\n\t\t},\r\n\r\n\t\tjoin : function(email, onJoin){\r\n\t\t\tthis.socket.emit('join', email, onJoin);\r\n\t\t}\r\n\r\n\t};\t\r\n\r\n\tvar bindUI = function(){\r\n\t\t$(\".join-chat\").validate({\r\n\t\t\tsubmitHandler: function(form) {\r\n\t\t\t\tchatAPI.join($(form).find(\"[name='email']\").val(), \r\n\t\t\t\t\tfunction(joined, name){\r\n\t\t\t\t\t\tif(joined){\r\n\t\t\t\t\t\t\talert(\"You've joined Chatzilla\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\r\n\tvar ready = function(){\r\n\t\tbindUI();\r\n\t\tconsole.log(\"Welcome to Chatzilla\");\r\n\t\tchatAPI.connect(function(){});\r\n\t};\r\n\r\n\r\n\r\n\t$(function(){ ready(); });\r\n\r\n}($,window));\r\n```\r\n\r\nCommit what you have and let's move on.\r\n\r\n### Add Send Message UI\r\n\r\nOnce the connection is established, let's hide the join form and show some kind of message composer:\r\n\r\n```html\r\n<form class=\"compose-message-form\" style=\"display:none;\">\r\n\t<textarea name=\"message\" required></textarea>\r\n\t<input type=\"submit\" value=\"send\">\r\n</form>\r\n```\r\n\r\nOur chatAPI module will need a new method (sendMessage): \r\n\r\n```javascript\r\nvar chatAPI = {\r\n\tconnect : function(done) {\r\n\t\tthis.socket = io.connect('/chat');\r\n\t\tthis.socket.on('connect', done);\r\n\t},\r\n\r\n\tjoin : function(email, onJoin){\r\n\t\tthis.socket.emit('join', email, onJoin);\r\n\t},\r\n\r\n\tsendMessage : function(message, onSent) {\r\n\t\tthis.socket.emit('message', message, onSent);\r\n\t}\r\n};\t\r\n```\r\n\r\nAnd here's what chatzilla.js looks like now \r\n\r\n```javascript\r\n(function($,window){\r\n\t\r\n\tvar chatAPI = {\r\n\r\n\t\tconnect : function(done) {\r\n\t\t\tthis.socket = io.connect('/chat');\r\n\t\t\tthis.socket.on('connect', done);\r\n\t\t},\r\n\r\n\t\tjoin : function(email, onJoin){\r\n\t\t\tthis.socket.emit('join', email, onJoin);\r\n\t\t},\r\n\r\n\t\tsendMessage : function(message, onSent) {\r\n\t\t\tthis.socket.emit('message', message, onSent);\r\n\t\t}\r\n\r\n\t};\t\r\n\r\n\tvar bindUI = function(){\r\n\t\t$(\".join-chat\").validate({\r\n\t\t\tsubmitHandler: function(form) {\r\n\t\t\t\tchatAPI.join($(form).find(\"[name='email']\").val(), \r\n\t\t\t\t\tfunction(joined, name) {\r\n\t\t\t\t\t\tif(joined){\r\n\t\t\t\t\t\t\talert(\"You've joined Chatzilla\");\r\n\t\t\t\t\t\t\t$(form).hide();\r\n\t\t\t\t\t\t\t$(\".compose-message-form\").show();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t$(\".compose-message-form\").validate({\r\n\t\t\tsubmitHandler: function(form) {\r\n\t\t\t\tchatAPI.sendMessage($(form).find(\"[name='message']\").val(), \t\t\t\t\tfunction(sent,message){\r\n\t\t\t\t\t\tif(sent){\r\n\t\t\t\t\t\t\talert(\"Your message was sent\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\r\n\tvar ready = function(){\r\n\t\tbindUI();\r\n\t\tconsole.log(\"Welcome to Chatzilla\");\r\n\t\tchatAPI.connect(function(){});\r\n\t};\r\n\r\n\r\n\r\n\t$(function(){ ready(); });\r\n\r\n}($,window));\r\n```\r\n\r\nNotice, how we are handling the message form in a similar way + we toggle visibility on both forms after joining chat.\r\n\r\nCommit what you have and let's move on.\r\n\r\n## Add Message List UI\r\n\r\nAs any respectable Chat application out there Chatzilla needs a list of messages that people are exchanging. Let's build it. \r\n\r\nFirst, let's figure out how this impacts our chatApi module. We'll have chatAPI trigger a handler once a new message is received: \r\n\r\n```javascript\r\n\r\nconnect : function(done) {\r\n\t\r\n\tvar that = this;\r\n\r\n\tthis.socket = io.connect('/chat');\r\n\tthis.socket.on('connect', done);\r\n\r\n\tthis.socket.on('message', function(message){\r\n\t\tif(that.onMessage){\r\n\t\t\tthat.onMessage(message);\r\n\t\t}\r\n\t});\r\n},\r\n\r\n``` \r\n\r\nAnd then in the bindUI, we can do the following:\r\n\r\n```javascript\r\nchatAPI.onMessage = function(message){\r\n\talert(\"you got a message: \" + message);\r\n};\r\n```\r\n\r\nchatzilla.js now looks like this\r\n\r\n```javascript\r\n(function($,window){\r\n\t\r\n\tvar chatAPI = {\r\n\r\n\t\tconnect : function(done) {\r\n\r\n\t\t\tvar that = this;\r\n\r\n\t\t\tthis.socket = io.connect('/chat');\r\n\t\t\tthis.socket.on('connect', done);\r\n\r\n\t\t\tthis.socket.on('message', function(message){\r\n\t\t\t\tif(that.onMessage){\r\n\t\t\t\t\tthat.onMessage(message);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tjoin : function(email, onJoin){\r\n\t\t\tthis.socket.emit('join', email, onJoin);\r\n\t\t},\r\n\r\n\t\tsendMessage : function(message, onSent) {\r\n\t\t\tthis.socket.emit('message', message, onSent);\r\n\t\t}\r\n\r\n\t};\t\r\n\r\n\tvar bindUI = function(){\r\n\r\n\t\t$(\".join-chat\").validate({\r\n\t\t\tsubmitHandler: function(form) {\r\n\t\t\t\tchatAPI.join($(form).find(\"[name='email']\").val(), \r\n\t\t\t\t\tfunction(joined, name){\r\n\t\t\t\t\t\tif(joined){\r\n\t\t\t\t\t\t\talert(\"You've joined Chatzilla\");\r\n\t\t\t\t\t\t\t$(form).hide();\r\n\t\t\t\t\t\t\t$(\".compose-message-form\").show();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t$(\".compose-message-form\").validate({\r\n\t\t\tsubmitHandler: function(form) {\r\n\t\t\t\tchatAPI.sendMessage($(form).find(\"[name='message']\").val(), \r\n\t\t\t\t\tfunction(sent,message){\r\n\t\t\t\t\t\tif(sent){\r\n\t\t\t\t\t\t\talert(\"Your message was sent\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tchatAPI.onMessage = function(message){\r\n\t\t\talert(\"you got a message: \" + message);\r\n\t\t};\r\n\r\n\t};\r\n\r\n\tvar ready = function(){\r\n\t\tbindUI();\r\n\t\tconsole.log(\"Welcome to Chatzilla\");\r\n\t\tchatAPI.connect(function(){});\r\n\t};\r\n\r\n\r\n\r\n\t$(function(){ ready(); });\r\n\r\n}($,window));\r\n```\r\n\r\nLet's get rid of the alerts by creating a container for the messages in the landing.html. After we update the section of the landing.html it looks like this \r\n\r\n```html\r\n<section>\r\n\t<form class=\"join-chat\">\r\n\t\t<label>Type your email to join the chat</label>\r\n\t\t<input name=\"email\" type=\"email\">\r\n\t\t<input type=\"submit\" value=\"Join\">\r\n\t</form>\r\n\r\n\t<ul class=\"messages\" style=\"display:none;\"></ul>\r\n\r\n\t<form class=\"compose-message-form\" style=\"display:none;\">\r\n\t\t<textarea name=\"message\" required></textarea>\r\n\t\t<input type=\"submit\" value=\"send\">\r\n\t</form>\r\n</section>\r\n```\r\n\r\nNotice that the message list is initially invisible. We'll show it once a person joins the chat (just like with the message form)\r\n\r\n\r\n```javascript\r\n$(\".messages\").show();\r\n```\r\n\r\nLet's update the onMessage handler so that it displays the message within the list: \r\n\r\n```javascript\r\nchatAPI.onMessage = function(message){\r\n\t$(\".messages\").append(\r\n\t\tjQuery(\"<li>\").html(message)\r\n\t);\r\n};\r\n``` \r\nCheckout the result (2+ tabs). Commit, grab a drink.\r\n\r\n## More context\r\n\r\nCurrent version of Chatzilla has a number of issues. The most noticeable one is that you can't really tell who the messages you receive come from. Let's fix that.\r\n\r\n### Session\r\n\r\nWe can take advantage of session data to keep track of the message sender. Let's modify on_join handler for the ChatNamespace in chatzilla.py\r\n\r\n```python\r\ndef on_join(self, email):\r\n\tself.log(\"%s joined chat\" % email)\r\n    self.session['email'] = email\r\n    return True, email\r\n```\r\n\r\nThis will allow to keep track of who's sending a message and we can use this data when we broadcast messages to others in the chat\r\n\r\n```python\r\ndef on_message(self, message):\r\n\tself.log('got a message: %s' % message)\r\n    self.broadcast_event_not_me(\"message\",{ \r\n    \t\"sender\" : self.session[\"email\"], \r\n    \t\"content\" : message})\r\n    return True, message\r\n```\r\n### Tell the client\r\n\r\nWe can now update chatzilla.js to take advantage of this additional information\r\n\r\n```javascript\r\nchatAPI.onMessage = function(message){\r\n\t$(\".messages\").append(\r\n\t\tjQuery(\"<li>\").html(\r\n\t\t\t\"<b>\" + message.sender + \"</b>: \" + message.content \r\n\t\t)\r\n\t);\r\n};\r\n```\r\n\r\nLet's also make sure your own message are added to the list once sent:\r\n\r\n```javascript\r\n$(\".compose-message-form\").validate({\r\n\t\t\tsubmitHandler: function(form) {\r\n\t\t\t\tchatAPI.sendMessage($(form).find(\"[name='message']\").val(), \t\t\t\t\tfunction(sent,message){\r\n\t\t\t\t\t\tif(sent){\r\n\t\t\t\t\t\t\t$(\".messages\").append(\r\n\t\t\t\t\t\t\t\tjQuery(\"<li>\").html(\r\n\t\t\t\t\t\t\t\t\t\"<b>Me</b>: \" + message\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n```\r\n\r\nCommit what you have. And push what you have to heroku.\r\n\r\n```\r\ngit push heroku master\r\n```\r\n\r\n### Before you panic\r\n\r\nAll the code for chapter 3 is [here](https://github.com/callmephilip/chatzilla/releases/tag/v0.3) if you need it.\r\n\r\n\r\n## Chapter 4: More UI\r\n\r\nThe final version of the app is available [here](http://chatzilla.herokuapp.com/). You'll notice it's quite different from where we left in Chapter 3. All the code is available [here](https://github.com/callmephilip/chatzilla).\r\n\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}